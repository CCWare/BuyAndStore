//
//  ShopFolderAppDelegate.m
//  ShopFolder
//
//  Created by Michael on 2011/09/07.
//  Copyright 2011å¹´ CCTSAI. All rights reserved.
//

#import "ShopFolderAppDelegate.h"
#import "UIApplication+BadgeUpdate.h"
#import "ExpiryNotificationScheduler.h"
#import "FlurryAnalytics.h"
#import "UIDevice+machine.h"
#import "FlurryKey.h"
#import "UAPush.h"
#import "TimeUtil.h"
#import "VersionCompare.h"
#import "CoreDataDatabase.h"
#import <DropboxSDK/DropboxSDK.h>

@interface ShopFolderAppDelegate ()
- (void)_applicationDidLaunch;
@end

@implementation ShopFolderAppDelegate

@synthesize window=_window;

void uncaughtExceptionHandler(NSException *exception) {
    [FlurryAnalytics logError:@"Uncaught" message:@"Crash!" exception:exception];
}

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [CoreDataDatabase class];   //make sure mainMOC is generated by main thread
    [ExpiryNotificationScheduler class];
    
    //Remove "(A Document Being Saved By " folders if its empty
    NSError *error;
    NSURL *libraryPath = [[[NSFileManager defaultManager] URLsForDirectory:NSLibraryDirectory inDomains:NSUserDomainMask] lastObject];
    NSArray *libraryContents = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:libraryPath
                                                              includingPropertiesForKeys:nil
                                                                                 options:NSDirectoryEnumerationSkipsHiddenFiles
                                                                                   error:&error];
    for(NSURL *url in libraryContents) {
        if([[url path] rangeOfString:@"(A Document Being Saved By "].location != NSNotFound) {
            if(![[NSFileManager defaultManager] removeItemAtURL:url error:&error]) {
                NSLog(@"Cannot remove %@, error: %@", [[[url path] componentsSeparatedByString:@"/"] lastObject], error);
            }
        }
    }
    
    [[NSUserDefaults standardUserDefaults] registerDefaults:
     [NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"Defaults" ofType:@"plist"]]];
    
    NSSetUncaughtExceptionHandler(&uncaughtExceptionHandler);
#ifndef DEBUG
    if([[NSUserDefaults standardUserDefaults] boolForKey:kSettingAllowAnalysis]) {
        [FlurryAnalytics startSession:kFlurryKey];
        [FlurryAnalytics logAllPageViews:_navCtrl];
    }
#endif
    
    NSLocale *locale = [NSLocale currentLocale];
    NSString *countryCode = [locale objectForKey: NSLocaleCountryCode];
    
    //Init Airship launch options
    NSMutableDictionary *takeOffOptions = [[NSMutableDictionary alloc] init];
    [takeOffOptions setValue:launchOptions forKey:UAirshipTakeOffOptionsLaunchOptionsKey];
    
    // Build the Urban Airship TakeOffOptions
    NSMutableDictionary *airshipConfigOptions = [[NSMutableDictionary alloc] init];
#ifdef _LITE_
    // Build the Urban Airship TakeOffOptions
    if([countryCode isEqualToString:@"TW"]) {
        [airshipConfigOptions setValue:@"_hkCrcyYTK6bURWh-_Vzqw" forKey:@"DEVELOPMENT_APP_KEY"];
        [airshipConfigOptions setValue:@"B-d0_Q8EQvCFOULVo9cL6A" forKey:@"DEVELOPMENT_APP_SECRET"];
        [airshipConfigOptions setValue:@"GhzlDk-uQ-Szzaa2pkmdtw" forKey:@"PRODUCTION_APP_KEY"];
        [airshipConfigOptions setValue:@"zSEnBErRRiSpMIb1q1YYvQ" forKey:@"PRODUCTION_APP_SECRET"];
    } else {
        [airshipConfigOptions setValue:@"z93ZA519RWaUlEMUsGQ5uA" forKey:@"DEVELOPMENT_APP_KEY"];
        [airshipConfigOptions setValue:@"a_3Epqw4SwemsBczYLURdQ" forKey:@"DEVELOPMENT_APP_SECRET"];
        [airshipConfigOptions setValue:@"E0-3YA_7SriYih97gLlPeg" forKey:@"PRODUCTION_APP_KEY"];
        [airshipConfigOptions setValue:@"rjFCd3amTkutPZ-xNTPh0g" forKey:@"PRODUCTION_APP_SECRET"];
    }
#else
    if([countryCode isEqualToString:@"TW"]) {
        [airshipConfigOptions setValue:@"QViOphsBSIe3dhoH8XA7iA" forKey:@"DEVELOPMENT_APP_KEY"];
        [airshipConfigOptions setValue:@"-rYzVJTdRveLPXtCHjBuhA" forKey:@"DEVELOPMENT_APP_SECRET"];
        [airshipConfigOptions setValue:@"aFk6XxFDSaOu6YxVkMtDYw" forKey:@"PRODUCTION_APP_KEY"];
        [airshipConfigOptions setValue:@"N4TiUPLkShGmJkVI0AjhWw" forKey:@"PRODUCTION_APP_SECRET"];
    } else {
        [airshipConfigOptions setValue:@"BkRVcddgThe7D40wpJRstw" forKey:@"DEVELOPMENT_APP_KEY"];
        [airshipConfigOptions setValue:@"_EnizQCyTB6D6A5d26YehA" forKey:@"DEVELOPMENT_APP_SECRET"];
        [airshipConfigOptions setValue:@"DUitVkSOSJ2YjK7PtDq2Tw" forKey:@"PRODUCTION_APP_KEY"];
        [airshipConfigOptions setValue:@"bGQAhjA0S0-lMbHJldaOUA" forKey:@"PRODUCTION_APP_SECRET"];
    }
#endif
    
#ifdef DEBUG
    [airshipConfigOptions setValue:@"NO" forKey:@"APP_STORE_OR_AD_HOC_BUILD"];
#else
    [airshipConfigOptions setValue:@"YES" forKey:@"APP_STORE_OR_AD_HOC_BUILD"];
#endif
    //    [airshipConfigOptions setValue:@"NO" forKey:@"DELETE_KEYCHAIN_CREDENTIALS"];
    [takeOffOptions setValue:airshipConfigOptions forKey:UAirshipTakeOffOptionsAirshipConfigKey];
    
    // Create Airship singleton that's used to talk to Urban Airship servers.
    // Please populate AirshipConfig.plist with your info from http://go.urbanairship.com
    [UAirship takeOff:takeOffOptions];
    
    //Prepare dropbox
    DBSession* dbSession = [[DBSession alloc] initWithAppKey:@"0m83nhclr3796d1"
                                                   appSecret:@"t9sgp3pccgyx85t"
                                                        root:kDBRootAppFolder]; // either kDBRootAppFolder or kDBRootDropbox
    [DBSession setSharedSession:dbSession];
    
    //Update database before loading view controller
    
    //From now on, root view is _launchVC, _nacCtrl is the subView of it
    UIImage *launchImage = nil;
    if([[UIScreen mainScreen] bounds].size.height == 568) {
        launchImage = [UIImage imageNamed:@"Default-568h"];
    } else {
        launchImage = [UIImage imageNamed:@"Default"];
    }
    UIImageView *launchImageView = [[UIImageView alloc] initWithImage:launchImage];
    
    UIActivityIndicatorView *spinner = [[UIActivityIndicatorView alloc]
                                        initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhite];
    CGRect frame = spinner.frame;
    frame.origin.x = (self.window.frame.size.width-frame.size.width)/2.0f;
    frame.origin.y = 380;
    if([[UIScreen mainScreen] bounds].size.height == 568) {
        frame.origin.y += 44.0f;
    }
    spinner.frame = frame;
    spinner.alpha = 0.0f;
    [launchImageView addSubview:spinner];
    [spinner startAnimating];
    
    [UIView animateWithDuration:0.25f animations:^{
        spinner.alpha = 1.0f;
    }];
    
    //Prevent warning message "Application windows are expected to have a root view controller at the end of application launch"
    _mainScreenVC = [[ShopFolderViewController alloc] init];
    _navCtrl = [[UINavigationController alloc] initWithRootViewController:_mainScreenVC];
    _navCtrl.navigationBarHidden = YES;
    
    [_navCtrl.view addSubview:launchImageView];
    
    self.window.rootViewController = _navCtrl;
    [self.window makeKeyAndVisible];
    
    const NSTimeInterval DEFAULT_LAUNCH_TIME = 1.0f;
    NSDate *launchTime = [NSDate date];
    
    if([CoreDataDatabase needToUpgradeDatabase]) {
        frame = CGRectMake(10, frame.origin.y+frame.size.height+10.0f, [[UIScreen mainScreen] bounds].size.width-20.0f, 20.0f);
        UILabel *msgLabel = [[UILabel alloc] initWithFrame:frame];
        msgLabel.textColor = [UIColor lightGrayColor];
        msgLabel.textAlignment = UITextAlignmentCenter;
        msgLabel.text = NSLocalizedString(@"Upgrading Database", nil);
        msgLabel.backgroundColor = [UIColor clearColor];
        msgLabel.alpha = 0.0f;
        [launchImageView addSubview:msgLabel];
        
        [UIView animateWithDuration:0.25f animations:^{
            msgLabel.alpha = 1.0f;
        }];
        
        [CoreDataDatabase resetDatabase];
        dispatch_async(dispatch_queue_create("UpgradeDBQueue", NULL), ^{
            [CoreDataDatabase upgradeDatabase];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                [self _applicationDidLaunch];
                
                NSTimeInterval animationDelayTime = DEFAULT_LAUNCH_TIME - [[NSDate date] timeIntervalSinceDate:launchTime];
                if(animationDelayTime < 0.0f) {
                    animationDelayTime = 0.0f;
                }
                
                [UIView animateWithDuration:0.3f
                                      delay:animationDelayTime
                                    options:UIViewAnimationOptionCurveEaseOut
                                 animations:^{
                                     launchImageView.alpha = 0.0f;
                                 } completion:^(BOOL finished) {
                                     [launchImageView removeFromSuperview];
                                 }];
            });
        });
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            if([DataBackupRestoreAgent isLastOperationFail]) {
                [DataBackupRestoreAgent recoverFromLastFailOperation];
                [CoreDataDatabase renewMainMOC];
            }
            
            [self _applicationDidLaunch];
            
            NSTimeInterval animationDelayTime = DEFAULT_LAUNCH_TIME - [[NSDate date] timeIntervalSinceDate:launchTime];
            if(animationDelayTime < 0.0f) {
                animationDelayTime = 0.0f;
            }
            
            [UIView animateWithDuration:0.3f
                                  delay:animationDelayTime
                                options:UIViewAnimationOptionCurveEaseOut
                             animations:^{
                                 launchImageView.alpha = 0.0f;
                             } completion:^(BOOL finished) {
                                 [launchImageView removeFromSuperview];
                             }];
        });
    }
    
    return YES;
}

- (void)_applicationDidLaunch
{
    NSString *notifVersion = [[NSUserDefaults standardUserDefaults] stringForKey:kNotificationVersion];
    if([VersionCompare compareVersion:kCurrentNotificationVersion toVersion:notifVersion] != NSOrderedSame ||
       ![[NSUserDefaults standardUserDefaults] boolForKey:kHasScheduledNotifications])
    {
        [ExpiryNotificationScheduler rescheduleAllNotifications];   //Will refresh badge
    } else {
        [[UIApplication sharedApplication] refreshApplicationBadgeNumber];
    }
    
    // Register for notifications
    [[UIApplication sharedApplication]
     registerForRemoteNotificationTypes:(//UIRemoteNotificationTypeBadge |
                                         UIRemoteNotificationTypeSound |
                                         UIRemoteNotificationTypeAlert)];
    
    [_mainScreenVC reloadPages];
    
    if([_mainScreenVC shouldShowExpiryList]) {
        [_mainScreenVC showExpireListAnimated:NO];
    }
}

- (void)applicationWillResignActive:(UIApplication *)application
{
    /*
     Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
     Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
     */
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
    /*
     Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
     If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
     */

    for(FolderPageViewController *pageVC in _mainScreenVC.pageVCs) {
        [pageVC stopLoadingImages];
    }
}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
     */
    BOOL isInProtectedFolder = [[NSUserDefaults standardUserDefaults] boolForKey:kIsInProtectedFolder];
    if(isInProtectedFolder) {
        [_navCtrl setNavigationBarHidden:YES animated:NO];
        [_navCtrl popToRootViewControllerAnimated:NO];
        
        [[NSUserDefaults standardUserDefaults] setBool:NO forKey:kIsInProtectedFolder];
        [[NSUserDefaults standardUserDefaults] synchronize];
    }
    
    if(![[NSUserDefaults standardUserDefaults] boolForKey:kIsInShoppingList]) {
        NSNumber *isContinue = [NSNumber numberWithBool:YES];
        for(FolderPageViewController *pageVC in _mainScreenVC.pageVCs) {
            [pageVC refreshFolderImagesContinuously:isContinue];
        }
    }
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{
    /*
     Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
     */

    //Add notofication listerner
}

- (void)applicationWillTerminate:(UIApplication *)application
{
    /*
     Called when the application is about to terminate.
     Save data if appropriate.
     See also applicationDidEnterBackground:.
     */
    [UAirship land];
    
    for(FolderPageViewController *pageVC in _mainScreenVC.pageVCs) {
        [pageVC stopLoadingImages];
    }
}

- (void)applicationSignificantTimeChange:(UIApplication *)application
{
    NSLog(@"Receive signigicant time change");
    [application refreshApplicationBadgeNumber];
}

- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
    // Updates the device token and registers the token with UA
    [[UAirship shared] registerDeviceToken:deviceToken];
}

- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{
    [FlurryAnalytics logEvent:@"Receive push notification"
               withParameters:[NSDictionary dictionaryWithObject:[NSNumber numberWithInt:[application applicationState]]
                                                          forKey:@"AppState"]];

    if([application applicationState] != UIApplicationStateActive) {
        return;
    }

    NSDictionary *aps = [userInfo objectForKey:@"aps"];
    NSString *alert = [aps objectForKey:@"alert"];
    
    if([alert length] > 0) {
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:NSLocalizedString(@"App Message", nil)
                                                            message:alert
                                                           delegate:nil
                                                  cancelButtonTitle:NSLocalizedString(@"Dismiss", nil)
                                                  otherButtonTitles:nil];
        [alertView show];
    }
}

//==============================================================
//  [BEGIN] Local notifications
#pragma mark - Local notifications
//--------------------------------------------------------------
- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification
{
//    NSLog(@"Receive local notification");
    if(application.applicationState == UIApplicationStateActive) {
        if(notification.applicationIconBadgeNumber > 0) {
            application.applicationIconBadgeNumber = notification.applicationIconBadgeNumber;
        }
    }
}
//--------------------------------------------------------------
//  [END] Local notifications
//==============================================================
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
{
    if ([[DBSession sharedSession] handleOpenURL:url]) {
        if ([[DBSession sharedSession] isLinked]) {
            NSLog(@"App linked successfully!");
            // At this point you can start making API calls
        }
        return YES;
    }
    // Add whatever other url handling code your app requires here
    return NO;
}
@end
